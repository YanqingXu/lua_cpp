# AI助手Spec-Kit命令参考手册

*基于Spec-Kit v0.0.17为lua_cpp项目定制的AI助手工作流指南*

## 🎯 Spec-Kit核心理念

**Specification-Driven Development (SDD)** 是一套完整的软件开发方法论，通过规格驱动确保高质量、可维护的代码实现。

### 7步SDD标准流程
```
Constitution → Specify → Clarify → Plan → Tasks → Analyze → Implement
   建立原则   →  写规格  →  澄清   → 计划 → 任务 →  分析  →   实施
```

---

## 📋 **AI助手工作流命令** 

### 🏛️ `/constitution` - 项目宪法管理
**用途**: 建立和维护项目不可变原则
**lua_cpp专用**: 现代C++质量标准 + Lua兼容性原则

```markdown
**执行场景**:
- 新项目启动时建立核心原则
- 重大技术决策前的原则确认  
- 代码审查时的合规性检查

**lua_cpp核心宪法**:
- 100% Lua 5.1.5语义兼容
- 现代C++17/20最佳实践
- 90%+测试覆盖率要求
- 零内存泄露保证
- 双重参考项目验证

**示例使用**:
"在T022 Parser实现前，请确认递归下降vs LALR选择是否符合项目宪法"
```

### 📝 `/specify` - 功能规格定义  
**用途**: 创建详细的功能规格文档
**lua_cpp专用**: Lua语法解析规格 + C++实现契约

```markdown
**执行场景**:
- 新功能开发前的规格定义
- 复杂算法的行为规格化
- API接口的契约制定

**lua_cpp规格示例**:
- Parser语法规则规格
- 垃圾收集器算法规格  
- C API兼容性规格

**文件位置**: specs/ 目录下的各个规格文档
```

### ❓ `/clarify` - 歧义澄清 (v0.0.17新增)
**用途**: 结构化澄清技术实现中的歧义和不确定性
**lua_cpp专用**: Parser实现、性能优化、兼容性决策

```markdown
**执行场景**:
- 技术实现方案选择 (如：递归下降 vs LALR)
- 性能优化策略决策
- 兼容性权衡取舍
- 错误处理策略确定

**澄清分类体系 (lua_cpp)**:
1. **技术架构类**
   - 解析器类型选择 (递归下降/LALR/手写)
   - 内存管理策略 (智能指针/原始指针/混合)
   - 异常处理方式 (异常/错误码/Result类型)

2. **兼容性类**  
   - Lua行为边界情况处理
   - C API调用约定
   - 数值类型精度保持

3. **性能类**
   - 解析性能优化点
   - 内存分配策略
   - 缓存机制设计

**使用模板**:
```
/clarify 
主题: [T022 Parser实现] 递归下降解析器设计歧义
歧义: 在处理左递归表达式时，应该使用优先级攀升还是算符优先级解析？
影响: 解析性能、代码复杂度、维护性
参考: lua_c_analysis/lparser.c 使用了优先级攀升
```

### 🔍 `/analyze` - 质量一致性分析 (v0.0.17新增)  
**用途**: 跨文档一致性验证和质量门禁检查
**lua_cpp专用**: 宪法合规、规格-实现一致性、参考项目对比

```markdown
**执行场景**:
- 实施前的准备度验证
- 代码审查时的一致性检查
- 里程碑完成时的质量验证

**分析维度 (lua_cpp)**:

1. **宪法合规性**
   - 所有技术决策是否符合项目宪法
   - C++标准使用是否规范
   - 测试覆盖率是否达标

2. **规格-实现一致性**
   - Contract tests vs 实际实现
   - 接口定义 vs 函数签名  
   - 错误处理规格 vs 异常实现

3. **参考项目对比**
   - lua_c_analysis 行为差异分析
   - lua_with_cpp 架构一致性检查
   - 性能基准对比验证

**使用示例**:
```
/analyze
检查范围: T022 Parser实现准备度
验证点: 
- AST接口与Parser接口兼容性
- Contract tests完整性
- 参考实现一致性
- 宪法合规性
```

### 📋 `/plan` - 技术实现计划
**用途**: 基于规格创建详细技术实现计划  
**lua_cpp专用**: C++实现路径 + 测试驱动开发计划

```markdown
**执行场景**:
- 复杂功能的实施规划
- 重构项目的步骤制定
- 性能优化的分阶段计划

**lua_cpp计划模板**:
1. **技术准备** - 依赖验证、工具准备
2. **TDD实施** - 测试用例编写、红绿重构
3. **参考验证** - 与lua_c_analysis行为对比
4. **集成测试** - 与现有组件集成验证
5. **性能基准** - 性能测试和优化
```

### ✅ `/tasks` - 任务列表生成
**用途**: 将实现计划分解为可执行的任务清单
**lua_cpp专用**: 分阶段实施 + 质量检查点

```markdown
**任务分解原则**:
- 每个任务2-4小时完成
- 明确的完成标准 
- 独立的测试验证
- 增量提交能力

**lua_cpp任务模板**:
- T0XX-A: 接口定义 + 单元测试框架
- T0XX-B: 核心算法实现 + 基础测试通过  
- T0XX-C: 错误处理 + 边界条件测试
- T0XX-D: 性能优化 + 基准测试
- T0XX-E: 参考验证 + 集成测试
```

### 🔧 `/implement` - 实施执行
**用途**: 执行具体的代码实现
**lua_cpp专用**: TDD + 现代C++ + 双重验证

```markdown
**实施标准流程**:
1. **红阶段**: 编写失败测试
2. **绿阶段**: 最小实现通过测试
3. **重构阶段**: 优化代码质量
4. **验证阶段**: 参考项目行为验证
5. **集成阶段**: 与现有代码集成

**lua_cpp实施检查点**:
- ✅ 编译无警告 (最严格级别)
- ✅ 单元测试100%通过
- ✅ Contract测试验证通过
- ✅ 内存检查无泄露
- ✅ 性能基准达标
```

---

## 🚀 **实际使用场景示例**

### 场景1: 开始T022 Parser实现

```markdown
步骤1: /clarify - 澄清Parser设计歧义
"递归下降解析器 vs 算符优先级解析器选择"

步骤2: /analyze - 验证实施准备
"检查AST接口、Lexer集成、Contract tests完整性"

步骤3: /implement - 开始编码实施
"TDD方式实现递归下降解析器"
```

### 场景2: 新AI会话快速上下文

```markdown
步骤1: 阅读AGENTS.md (2分钟项目全貌)
步骤2: /analyze - 当前状态验证
"检查T022准备情况和阻塞问题"

步骤3: /clarify - 澄清待解决问题  
"明确当前任务的技术决策点"

步骤4: /implement - 继续开发
"基于澄清结果开始/继续实施"
```

### 场景3: 代码审查和质量保证

```markdown
步骤1: /analyze - 实现质量分析
"验证代码与规格一致性、宪法合规性"

步骤2: /constitution - 原则合规检查
"确认技术决策符合项目宪法"

步骤3: 参考项目验证
"与lua_c_analysis行为对比，lua_with_cpp架构检查"
```

---

## 💡 **AI助手最佳实践**

### 工作流程建议

1. **新会话开始**:
   - 先读 `AGENTS.md` 建立完整上下文  
   - 用 `/analyze` 检查当前状态
   - 用 `/clarify` 解决歧义再开始工作

2. **复杂任务实施**:
   - 必须经过 `clarify → analyze → implement` 流程
   - 每个实现步骤都要有明确的测试验证
   - 遵循TDD红绿重构循环

3. **质量保证**:
   - 实施前必须 `/analyze` 验证准备度  
   - 实施中持续 `/constitution` 合规检查
   - 完成后参考项目双重验证

### lua_cpp项目特殊要求

- **双重参考验证**: 每个功能都需要lua_c_analysis行为验证 + lua_with_cpp架构验证
- **现代C++标准**: 充分利用C++17/20特性，RAII，智能指针
- **企业级质量**: 90%测试覆盖率，零内存泄露，最严格编译警告

---

**版本**: Spec-Kit v0.0.17  
**项目**: lua_cpp (现代C++ Lua 5.1.5解释器)  
**更新**: 2025-09-25
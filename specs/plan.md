# 技术实现计划：现代C++ Lua 5.1.5解释器

**分支**: `main-lua-interpreter` | **日期**: 2025-09-20 | **规格**: [lua-interpreter-spec.md](./lua-interpreter-spec.md)  
**输入**: 功能规格说明 `/specs/lua-interpreter-spec.md`  
**参考项目**: lua_c_analysis (原理理解) + lua_with_cpp (架构实践)

## 执行流程概览
```
1. 技术栈研究和选型 → 结合参考项目解决技术不确定性
2. 系统架构设计 → 基于参考项目的模块分解和接口定义
3. 数据模型设计 → 参考lua_c_analysis的核心类型和内存布局
4. 契约设计 → 基于两个参考项目的API接口和测试定义
5. 任务分解策略 → 集成参考项目验证的TDD开发任务规划
```

## 参考项目集成策略

### lua_c_analysis 项目利用方案
**角色**: 技术理解和行为基准参考
- **实现原理研究**: 每个模块开发前深入研读对应的C源码注释
- **行为兼容性验证**: 使用其测试用例和运行结果作为兼容性标准
- **性能基准**: 以其执行性能作为我们的最低性能要求
- **算法参考**: 学习其核心算法（GC、VM、表实现）的设计思想

### lua_with_cpp 项目借鉴方案
**角色**: 架构设计和质量标准参考
- **模块架构**: 参考其模块划分和接口设计原则
- **现代C++实践**: 学习其智能指针、模板和异常处理模式
- **测试架构**: 采用其测试框架和质量保证体系
- **代码质量**: 遵循其编码规范和静态分析标准

### 双重验证开发流程
**每个模块的标准开发流程**:
1. **理论研习**: 深入分析lua_c_analysis中对应模块的实现和注释
2. **架构设计**: 参考lua_with_cpp的模块设计和接口模式
3. **契约定义**: 结合两个项目的经验定义测试契约
4. **TDD实现**: 编写测试 → 实现功能 → 重构优化
5. **行为验证**: 与lua_c_analysis行为对比验证
6. **质量验证**: 按lua_with_cpp标准进行代码质量检查

## 项目概述
基于Lua 5.1.5参考实现，使用现代C++17/20特性构建完全兼容的高性能解释器。采用模块化架构设计，通过测试驱动开发确保100%兼容性和企业级质量。

## 技术背景分析

**语言/版本**: C++17 (最低要求), C++20 (推荐特性)  
**主要依赖**: STL标准库, Catch2测试框架, CMake构建系统  
**存储**: 内存管理 + 可选文件I/O  
**测试**: Catch2单元测试 + Google Benchmark性能测试  
**目标平台**: Windows/Linux/macOS, x86_64/ARM64  
**项目类型**: 单一项目 (核心解释器库 + CLI工具)  
**性能目标**: ≥原版95%执行速度, ≤原版120%内存使用  
**约束条件**: 100% Lua 5.1.5兼容性, 零内存泄漏, 编译零警告  
**规模范围**: ~50K行代码, 支持10万行Lua脚本, 13个核心模块

## 宪法检查
*门禁：必须在第0阶段研究前通过，第1阶段设计后重新检查*

✅ **Lua 5.1.5完全兼容性** - 通过官方测试套件验证  
✅ **现代C++架构设计** - 充分利用C++17/20特性，RAII和智能指针  
✅ **性能优先设计** - 基准测试驱动，零成本抽象原则  
✅ **模块化架构** - 清晰分层，组件独立，接口明确  
✅ **测试驱动开发** - TDD强制执行，90%覆盖率目标  

*所有宪法原则完全合规，无需复杂性例外*

## 项目结构

### 文档结构 (当前功能)
```
specs/
├── plan.md              # 本文件 (/plan命令输出)
├── research.md          # 第0阶段输出 (/plan命令)
├── data-model.md        # 第1阶段输出 (/plan命令)
├── quickstart.md        # 第1阶段输出 (/plan命令)
├── contracts/           # 第1阶段输出 (/plan命令)
│   ├── lua-api.h        # C API接口契约
│   ├── vm-interface.h   # 虚拟机接口契约
│   └── gc-interface.h   # 垃圾回收器接口契约
└── tasks.md             # 第2阶段输出 (/tasks命令 - 不由/plan创建)
```

### 源代码结构 (仓库根目录)
```
src/
├── core/                # 核心类型和基础设施
│   ├── lua_value.h/cpp  # 统一值类型系统
│   ├── lua_state.h/cpp  # Lua状态管理
│   └── lua_config.h     # 编译配置
├── lexer/               # 词法分析器
│   ├── lexer.h/cpp      # 词法分析器
│   └── token.h/cpp      # Token定义
├── parser/              # 语法分析器
│   ├── parser.h/cpp     # 递归下降解析器
│   └── ast.h/cpp        # 抽象语法树
├── compiler/            # 字节码编译器
│   ├── compiler.h/cpp   # 编译器主体
│   ├── opcode.h/cpp     # 操作码定义
│   └── debug_info.h/cpp # 调试信息
├── vm/                  # 虚拟机执行器
│   ├── vm.h/cpp         # 虚拟机核心
│   ├── stack.h/cpp      # 执行栈管理
│   └── dispatch.h/cpp   # 指令分发器
├── gc/                  # 垃圾回收器
│   ├── gc.h/cpp         # 垃圾回收器
│   └── object.h/cpp     # 对象生命周期
├── types/               # Lua数据类型
│   ├── string.h/cpp     # 字符串类型
│   ├── table.h/cpp      # 表类型
│   ├── function.h/cpp   # 函数类型
│   └── coroutine.h/cpp  # 协程类型
├── stdlib/              # 标准库实现
│   ├── base_lib.h/cpp   # 基础库
│   ├── string_lib.h/cpp # 字符串库
│   ├── table_lib.h/cpp  # 表库
│   ├── math_lib.h/cpp   # 数学库
│   ├── io_lib.h/cpp     # I/O库
│   └── os_lib.h/cpp     # 操作系统库
├── api/                 # C API接口
│   ├── lua_api.h/cpp    # 公共API
│   └── aux_lib.h/cpp    # 辅助库
└── cli/                 # 命令行工具
    └── lua_cli.cpp      # 解释器入口

tests/
├── contract/            # 契约测试
│   ├── api_contract/    # C API契约测试
│   ├── vm_contract/     # 虚拟机契约测试
│   └── compat_contract/ # 兼容性契约测试
├── integration/         # 集成测试
│   ├── lua_scripts/     # Lua脚本测试集
│   ├── performance/     # 性能基准测试
│   └── compatibility/   # 兼容性测试
└── unit/                # 单元测试
    ├── lexer_test/      # 词法分析器测试
    ├── parser_test/     # 语法分析器测试
    ├── compiler_test/   # 编译器测试
    ├── vm_test/         # 虚拟机测试
    ├── gc_test/         # 垃圾回收器测试
    └── types_test/      # 数据类型测试

benchmarks/              # 性能基准测试
├── execution/           # 执行性能测试
├── memory/              # 内存使用测试
└── startup/             # 启动时间测试

docs/                    # 项目文档
├── api/                 # API文档
├── architecture/        # 架构文档
└── examples/            # 使用示例
```

**结构决策**: 选择单一项目结构，核心解释器库+CLI工具

## 技术背景

**语言/版本**: C++17 (最低要求), C++20 (可选特性)  
**主要依赖**: STL, Catch2/GoogleTest, CMake 3.16+  
**存储**: 内存管理 + 可选文件I/O  
**测试**: Catch2, Google Benchmark, Valgrind  
**目标平台**: Windows 10+, Linux (Ubuntu 20.04+), macOS 10.15+  
**项目类型**: 单一项目 (解释器库 + 可执行文件)  
**性能目标**: ≥原版95%执行速度, ≤原版120%内存使用, <100ms启动时间  
**约束**: 零内存泄漏, 零编译警告, 100% Lua 5.1.5兼容性  
**规模/范围**: ~50K LOC, 支持10万行Lua脚本, 企业级质量

## 宪法检查
*门禁：阶段0研究前必须通过。阶段1设计后重新检查。*

### ✅ 核心原则合规性检查

**一. Lua 5.1.5 完全兼容性** ✓  
- 设计基于官方参考实现
- 完整的测试套件验证兼容性
- 行为严格遵循规范

**二. 现代C++架构设计** ✓  
- C++17/20特性充分利用
- RAII和智能指针设计
- 类型安全和模板使用

**三. 性能优先设计** ✓  
- 虚拟机优化策略明确
- 内存布局优化计划
- 基准测试驱动优化

**四. 模块化架构** ✓  
- 清晰的组件分离
- 定义良好的接口
- 独立可测试设计

**五. 测试驱动开发** ✓  
- TDD流程强制执行
- 90%覆盖率目标
- 全面测试策略

**门禁状态**: ✅ 通过 - 所有原则完全符合

## 项目结构

### 文档结构 (当前功能)
```
specs/
├── plan.md                    # 本文件 (/plan 命令输出)
├── research.md               # 阶段0输出 (/plan 命令)
├── data-model.md            # 阶段1输出 (/plan 命令)
├── quickstart.md            # 阶段1输出 (/plan 命令)
├── contracts/               # 阶段1输出 (/plan 命令)
│   ├── vm-interface.hpp     # 虚拟机接口契约
│   ├── parser-interface.hpp # 解析器接口契约
│   ├── gc-interface.hpp     # 垃圾回收接口契约
│   └── api-interface.hpp    # C API接口契约
└── tasks.md                 # 阶段2输出 (/tasks 命令)
```

### 源代码结构 (仓库根目录)
```
# 单一项目结构 (选择理由: 解释器是单一库项目)
include/
├── lua/                     # 公共头文件
│   ├── lua.hpp             # 主接口头文件
│   ├── lua_vm.hpp          # 虚拟机接口
│   ├── lua_types.hpp       # 类型定义
│   └── lua_config.hpp      # 编译配置

src/
├── core/                   # 核心组件
│   ├── vm/                # 虚拟机实现
│   ├── parser/            # 词法/语法分析
│   ├── compiler/          # 字节码编译
│   └── gc/                # 垃圾回收
├── stdlib/                # 标准库实现
│   ├── base/              # 基础库
│   ├── string/            # 字符串库
│   ├── table/             # 表操作库
│   └── math/              # 数学库
├── api/                   # C API实现
└── utils/                 # 工具和辅助

tests/
├── unit/                  # 单元测试
├── integration/           # 集成测试
├── compatibility/         # 兼容性测试
└── performance/           # 性能测试

tools/
├── lua/                   # Lua可执行文件
├── luac/                  # 编译器工具
└── benchmark/             # 性能测试工具

docs/
├── api/                   # API文档
├── architecture/          # 架构文档
└── examples/              # 示例代码
```

**结构决策**: 单一项目 - 解释器是独立的库项目，不涉及前端/后端分离

## 阶段0：大纲和研究（基于参考项目指导）

### 1. 参考项目导向的技术研究

#### lua_c_analysis 深度研究任务
- **虚拟机执行机制** - 深入分析 `lvm.c` 的指令分发和执行优化
  - 研究基于寄存器 vs 基于栈的VM架构差异
  - 分析跳转表优化和分支预测技术
  - 理解调用栈管理和异常处理机制
- **内存管理核心** - 深入理解 `lgc.c` 的垃圾回收算法
  - 三色标记算法的实现细节和性能特征
  - 增量收集的暂停时间控制策略
  - 弱引用和对象生命周期管理
- **数据结构实现** - 分析 `ltable.c` 和 `lstring.c` 的优化技术
  - 混合数组+哈希表的性能权衡
  - 字符串驻留的内存和速度优化
  - 对象头部设计和内存布局优化

#### lua_with_cpp 架构研究任务  
- **现代C++模式** - 学习其智能指针和RAII应用
  - `GCRef<T>` 智能指针的设计模式和性能影响
  - 异常安全和资源管理最佳实践
  - 模板元编程在类型系统中的应用
- **模块化设计** - 分析其组件分离和接口设计
  - 模块间依赖关系和解耦策略
  - 接口抽象和多态性的使用原则
  - 编译时间优化和头文件组织
- **测试架构** - 学习其质量保证体系
  - 测试用例组织和自动化策略
  - 性能回归测试的实现方法
  - 代码覆盖率工具集成

#### 技术决策对比研究
- **性能对比分析** - lua_c_analysis vs lua_with_cpp 性能特征
- **内存使用分析** - 两种实现方式的内存占用对比
- **维护性评估** - 代码复杂度和可维护性权衡

### 2. 参考项目指导的研究代理调度

```
lua_c_analysis 深度分析:
  任务: "深入分析lvm.c的指令执行优化技术"
  任务: "研究lgc.c的垃圾回收算法实现细节"
  任务: "分析ltable.c的混合数据结构设计"
  任务: "学习lstring.c的字符串驻留优化"

lua_with_cpp 架构学习:
  任务: "分析现代C++智能指针在VM中的应用"
  任务: "研究模块化架构和接口设计模式"
  任务: "学习测试驱动开发和质量保证体系"
  任务: "评估编译时间和运行时性能权衡"

综合技术决策:
  任务: "对比两个项目的性能和可维护性"
  任务: "制定lua_cpp的技术栈选择策略"
  任务: "设计参考项目验证和集成流程"
```

### 3. 基于参考项目的技术选型策略

将在 `research.md` 中使用以下格式整合所有发现：
- **决策**: [选择的技术方案]
- **理由**: [选择的原因]
- **替代方案**: [评估过的其他选择]

**输出**: research.md - 解决所有技术不确定性

现在开始创建第0阶段的研究文档：

✅ **第0阶段完成** - research.md已创建，所有技术决策已确定
✅ **第1阶段完成** - 数据模型、接口契约、快速开始文档已创建

已创建的文档：
- ✅ [research.md](./research.md) - 技术研究和决策
- ✅ [data-model.md](./data-model.md) - 核心数据模型设计  
- ✅ [contracts/lua-api.h](./contracts/lua-api.h) - C API接口契约
- ✅ [contracts/vm-interface.h](./contracts/vm-interface.h) - 虚拟机接口契约
- ✅ [contracts/gc-interface.h](./contracts/gc-interface.h) - 垃圾回收器接口契约
- ✅ [quickstart.md](./quickstart.md) - 快速开始验证指南

## 阶段1：设计和契约

*前提条件: research.md 完成*

### 1. 数据模型提取 → `data-model.md`

#### 核心实体设计
```cpp
// 主要数据类型
class LuaValue {
    enum Type : uint8_t {
        NIL, BOOLEAN, NUMBER, STRING, 
        TABLE, FUNCTION, USERDATA, THREAD
    };
    // 统一值表示，优化内存布局
};

class LuaTable {
    // 哈希表 + 数组混合实现
    // 针对Lua表的特性优化
};

class LuaFunction {
    // 函数和闭包的统一表示
    // 支持C函数和Lua函数
};

class LuaState {
    // 虚拟机状态管理
    // 线程安全考虑
};
```

#### 关系和验证规则
- 值类型转换规则和验证
- 表的键值约束和哈希策略
- 函数调用栈的状态转换
- 垃圾回收的对象引用关系

### 2. API契约生成

#### 核心接口契约
- **虚拟机接口** (`vm-interface.hpp`): 执行引擎的核心API
- **解析器接口** (`parser-interface.hpp`): 词法和语法分析API
- **垃圾回收接口** (`gc-interface.hpp`): 内存管理API
- **C API接口** (`api-interface.hpp`): 兼容Lua 5.1.5的C接口

#### 标准设计模式
- 现代C++接口设计（纯虚基类 + RAII）
- 异常安全保证和错误处理
- 模板特化和编译时优化

### 3. 契约测试生成

为每个接口生成失败的测试：
- 虚拟机执行测试（指令分发、栈操作）
- 解析器测试（语法正确性、错误处理）
- 垃圾回收测试（内存泄漏、回收正确性）
- C API兼容性测试（所有函数行为验证）

### 4. 测试场景提取

从用户故事生成集成测试：
- Lua脚本执行完整流程
- C++应用嵌入Lua解释器
- 性能敏感应用的实时执行

### 5. 代理文件更新

运行PowerShell脚本更新开发上下文：
```powershell
scripts/powershell/update-agent-context.ps1 -AgentType CLAUDE
```

**输出**: data-model.md, /contracts/*, 失败的测试, quickstart.md, CLAUDE.md

## 阶段2：任务规划方法

*本节描述 /tasks 命令将执行的工作 - 不在 /plan 期间执行*

### 任务生成策略

**基础模板**: 加载 `tasks-template.md` 作为基础结构

**从设计文档生成任务**:
- 每个契约接口 → 契约测试任务 [P]
- 每个核心实体 → 模型创建任务 [P]
- 每个用户故事 → 集成测试任务
- 实现任务使测试通过

**具体任务映射**:
```
契约 → 测试任务:
- vm-interface.hpp → VM契约测试 [P]
- parser-interface.hpp → 解析器契约测试 [P]
- gc-interface.hpp → GC契约测试 [P]
- api-interface.hpp → C API契约测试 [P]

实体 → 模型任务:
- LuaValue → 值类型实现 [P]
- LuaTable → 表实现 [P]
- LuaFunction → 函数实现 [P]
- LuaState → 状态管理实现 [P]
```

### 排序策略

**TDD顺序**: 测试先于实现
**依赖顺序**: 基础类型 → 核心组件 → 标准库 → API层
**并行标记**: [P] 标记独立文件的并行执行

**优先级分层**:
1. 核心数据类型和内存管理
2. 词法和语法分析器
3. 字节码编译器
4. 虚拟机执行引擎
5. 垃圾回收器
6. 标准库实现
7. C API层
8. 工具和调试接口

### 预估输出

**任务数量**: 40-50个编号、有序的任务
**文件**: tasks.md 包含详细的实现步骤
**时间估算**: 每个任务的预估工作量
**依赖关系**: 明确的任务依赖图

**重要**: 此阶段由 /tasks 命令执行，而非 /plan

## 阶段3+：未来实现

*这些阶段超出 /plan 命令的范围*

**阶段3**: 任务执行 (/tasks 命令创建 tasks.md)  
**阶段4**: 实现 (按照宪法原则执行 tasks.md)  
**阶段5**: 验证 (运行测试、执行 quickstart.md、性能验证)

## 复杂度跟踪

*仅在宪法检查有需要证明的违规时填写*

当前设计完全符合宪法原则，无需复杂度证明。

| 违规 | 需要原因 | 拒绝简化方案的原因 |
|------|----------|-------------------|
| 无   | 无       | 无                |

## 进度跟踪

*此检查清单在执行流程中更新*

**阶段状态**:
- [x] 阶段0: 研究完成 (/plan 命令) ✅ research.md
- [x] 阶段1: 设计完成 (/plan 命令) ✅ data-model.md, contracts/, quickstart.md
- [x] 阶段2: 任务规划方法完成 (/plan 命令 - 仅描述方法)
- [x] 阶段3: 任务生成 (/tasks 命令) ✅ tasks.md - 58个结构化任务
- [ ] 阶段4: 实现完成
- [ ] 阶段5: 验证通过

**门禁状态**:
- [x] 初始宪法检查: 通过
- [x] 设计后宪法检查: 通过 (设计完全符合)
- [x] 所有技术不确定性已解决 ✅ research.md
- [x] 复杂度偏差已记录 (无偏差)
- [x] 任务完整性验证: 通过 ✅ tasks.md

---
*基于宪法 v1.0.0 - 参见 `/memory/constitution.md`*